The median is the middle value in an ordered integer list. If the size of the list is even, there is no middle value. So the median is the mean of the two middle values.

For examples, if arr = [2,3,4], the median is 3.
For examples, if arr = [1,2,3,4], the median is (2 + 3) / 2 = 2.5.
You are given an integer array nums and an integer k. There is a sliding window of size k which is moving from the very left of the array to the very right. You can only see the k numbers in the window. Each time the sliding window moves right by one position.

Return the median array for each window in the original array. Answers within 10-5 of the actual value will be accepted.

 

Example 1:

Input: nums = [1,3,-1,-3,5,3,6,7], k = 3
Output: [1.00000,-1.00000,-1.00000,3.00000,5.00000,6.00000]
Explanation: 
Window position                Median
---------------                -----
[1  3  -1] -3  5  3  6  7        1
 1 [3  -1  -3] 5  3  6  7       -1
 1  3 [-1  -3  5] 3  6  7       -1
 1  3  -1 [-3  5  3] 6  7        3
 1  3  -1  -3 [5  3  6] 7        5
 1  3  -1  -3  5 [3  6  7]       6
Example 2:

Input: nums = [1,2,3,4,2,3,1,4,2], k = 3
Output: [2.00000,3.00000,3.00000,3.00000,2.00000,3.00000,2.00000]
 

Constraints:

1 <= k <= nums.length <= 105
-231 <= nums[i] <= 231 - 1
Задача "Скользящая медиана"  
Нужно найти медиану для каждого положения окна фиксированного размера k, которое двигается по массиву. Медиана — это средний элемент в отсортированном списке. Если элементов чётное количество, медиана — среднее двух центральных.

Алгоритм решения:

1. Две кучи для балансировки элементов:
   - max_heap хранит меньшую половину элементов (максимальный элемент на вершине).
   - min_heap хранит большую половину (минимальный элемент на вершине).
   - В max_heap может быть на 1 элемент больше, чем в min_heap, если k нечётное.

2. Добавление элемента:
   - Новый элемент добавляется в max_heap, если он меньше или равен её вершине, иначе — в min_heap.
   - После добавления проверяется баланс между кучами:
     - Если max_heap больше min_heap более чем на 1, верхний элемент max_heap переносится в min_heap.
     - Если min_heap больше max_heap, верхний элемент min_heap переносится в max_heap.

3. Удаление устаревшего элемента:
   - При сдвиге окна удаляется элемент, выходящий за его границы.
   - Определяется, в какой куче находится элемент:
     - Если элемент ≤ вершины max_heap (после очистки удалённых), он удаляется из max_heap.
     - Иначе — из min_heap.
   - Удаление "ленивое" — элемент помечается как удалённый в хэш-таблице, чтобы физически убрать его позже.

4. Ленивое удаление и очистка куч:
   - Перед любыми операциями с вершинами куч удаляются все помеченные элементы с вершины.
   - Хэш-таблицы (`hash_map_max`, `hash_map_min`) отслеживают количество "удалённых" элементов в каждой куче.

5. Вычисление медианы:
   - После очистки куч:
     - Если k нечётное: медиана — вершина max_heap.
     - Если чётное: среднее между вершинами max_heap и min_heap.

Сложность:  
- Вставка и удаление элементов: O(log k).
- Балансировка куч: O(1).
- Общая сложность: O(n log k), где n — длина массива.

Ключевые моменты:
- Использование двух куч для разделения элементов на две половины.
- Ленивое удаление для эффективного управления элементами.
- Балансировка куч для поддержания корректного размера.
- Очистка вершин куч перед критическими операциями.
Задача (просто о сложном)  
Дан массив чисел и целое число *k*. Нужно последовательно «скользить» по этому массиву «окном» размера *k*:  

• На первом шаге окно включает первые *k* чисел массива.  

• На втором шаге — элементы со 2-го по (k+1)-й,  

• и так далее, пока окно не дойдет до конца массива.  

На каждом шаге нужно найти медиану чисел, попавших в текущее окно, и сохранить ее в ответ.

Что такое медиана?  

• Если в окне нечётное количество чисел *(k нечетное)*, медиана — это просто средний элемент, когда все числа окна отсортированы.  

• Если в окне чётное количество чисел *(k четное)*, медиана — это среднее арифметическое двух серединных элементов в отсортированном виде.

---

▎Подход к решению без кода

▎1. Наивный метод

1. Для каждого положения окна берем его элементы.

2. Сортируем элементы окна.

3. Находим медиану по определению (один элемент в случае нечетного *k*, или среднее арифметическое двух элементов в случае четного *k*).

4. Сдвигаем окно на 1 позицию вправо и повторяем всё заново.  

Сложность:  

• Сортировка окна из *k* элементов занимает O(k log k).  

• Из-за того, что мы двигаемся по окну (n - k + 1) раз, общая сложность будет O((n - k + 1) × k log k).  

• Это может быть достаточно медленно, если *n* и *k* очень большие.

▎2. Эффективный метод (две кучи или сбалансированное дерево)

Чтобы находить медиану более эффективно, часто используют структуру данных из двух куч (или сбалансированного дерева):

1. Max-куча (приоритетная очередь) — хранит меньшую половину чисел.

2. Min-куча — хранит большую половину чисел.

При этом заботимся о том, чтобы:  

• Все элементы *max*-кучи были меньше или равны всем элементам *min*-кучи.  

• Количество элементов в кучах различалось не более чем на 1. Благодаря этому медиана быстро определяется:  

  • Если суммарное количество элементов нечётно, медиана находится на вершине той кучи, где больше элементов.  

  • Если чётно, медиана — это среднее значений, лежащих на вершинах обеих куч.

Как адаптировать к «скользящему окну»:  

1. Сначала заполняем две кучи элементами первого окна. Балансируем (число элементов в кучах не должно отличаться больше чем на 1).  

2. Когда окно сдвигается на 1:

   • Удаляем выпадающий элемент (тот, что уходит из окна) из соответствующей кучи. Чтобы найти его эффективно, можно хранить «вспомогательную структуру» (к примеру, дерево поиска или индекс в куче), но в общем случае — это занимает O(log k) при наличии хорошей структуры данных.  

   • Добавляем новый элемент, который приходит в окно, в одну из куч так, чтобы сохранялся баланс. Тоже за O(log k).  

   • Смотрим на вершины куч и находим медиану.  

Сложность:  

• Каждый сдвиг окна (таких сдвигов (n - k + 1)) требует двух логарифмических операций (добавление и удаление с последующей балансировкой), то есть примерно O(log k) на один сдвиг.  

• Итоговая асимптотика: O(n log k).

---

▎Итоговая идея

• Если *n* небольшое или *k* велико, можно просто брать с каждого окна элементы, сортировать и находить медиану.  

• Если нужны лучшие результаты по времени на больших данных, используют сложные структуры (две кучи или дерево), чтобы добавлять и удалять элементы из окна за O(log k).  

• В результате медиа́ны собираются в итоговый массив, размер которого будет (n - k + 1).
Для эффективного нахождения медианы из массива в JavaScript можно использовать два подхода. Вот реализация базового метода с сортировкой (простой и понятный) и оптимизированного с использованием Quickselect (быстрее для больших данных).

---

### 1. Базовый метод (с сортировкой)
function findMedianBasic(arr) {
    if (arr.length === 0) return null;
    
    // Создаем копию и сортируем
    const sorted = [...arr].sort((a, b) => a - b);
    const mid = Math.floor(sorted.length / 2);
    
    // Для четного и нечетного количества элементов
    return sorted.length % 2 === 0 
        ? (sorted[mid - 1] + sorted[mid]) / 2 
        : sorted[mid];
}

Особенности:
- Простота реализации.
- Сложность: O(n log n) из-за сортировки.
- Подходит для небольших массивов.

---

### 2. Оптимизированный метод (Quickselect)
function findMedianOptimized(arr) {
    if (arr.length === 0) return null;

    const findKth = (k, left, right) => {
        while (true) {
            if (left === right) return arr[left];
            
            // Выбор опорного элемента и разделение массива
            let pivotIdx = partition(left, right);
            
            if (k === pivotIdx) return arr[k];
            else if (k < pivotIdx) right = pivotIdx - 1;
            else left = pivotIdx + 1;
        }
    };

    const partition = (left, right) => {
        const pivot = arr[right];
        let i = left;
        for (let j = left; j < right; j++) {
            if (arr[j] < pivot) {
                [arr[i], arr[j]] = [arr[j], arr[i]];
                i++;
            }
        }
        [arr[i], arr[right]] = [arr[right], arr[i]];
        return i;
    };

    const n = arr.length;
    const mid = Math.floor(n / 2);
    
    // Для нечетного и четного количества элементов
    if (n % 2 === 1) {
        return findKth(mid, 0, n - 1);
    } else {
        const a = findKth(mid - 1, 0, n - 1);
        const b = findKth(mid, 0, n - 1);
        return (a + b) / 2;
    }
}

Особенности:
- Использует алгоритм Quickselect для поиска k-го элемента без полной сортировки.
- Средняя сложность: O(n), но в худшем случае O(n^2).
- Подходит для больших массивов.

---

### Пример использования:
const data = [5, 2, 9, 1, 5, 6];
console.log(findMedianBasic(data)); // 5
console.log(findMedianOptimized(data)); // 5

### Как выбрать метод?
- Используйте `findMedianBasic`, если нужна простота и массив небольшой.
- Используйте `findMedianOptimized`, если данные очень большие и требуется оптимизация скорости (но учитывайте риск худшего случая).

 https://habr.com/ru/articles/346930/
ChatGPT 4.5 | DeepSeek | Midjourney, [31.03.2025 16:51]
Ниже мы возьмём код из предыдущего примера (две кучи, поиск медианы) и разберём его на более мелкие части, сопроводив пояснением «простыми словами».  

-----

▎1. Определение структуры MinHeap (минимальная куча)

▎Класс MinHeap

class MinHeap {
  constructor() {
    this.heap = [];
  }

  get size() {
    return this.heap.length;
  }

  peek() {
    return this.size === 0 ? undefined : this.heap[0];
  }

  push(value) {
    this.heap.push(value);
    this._heapifyUp(this.size - 1);
  }

  pop() {
    if (this.size === 0) return undefined;
    this._swap(0, this.size - 1);
    const minValue = this.heap.pop();
    this._heapifyDown(0);
    return minValue;
  }

  _heapifyUp(index) {
    // ...
  }

  _heapifyDown(index) {
    // ...
  }

  _swap(i, j) {
    // ...
  }
}


Что здесь происходит:  

1. Свойство heap: хранит все элементы кучи в виде массива.  

2. size: показывает, сколько сейчас элементов в куче.  

3. peek(): быстро получить «минимальный» элемент (для MinHeap это вершина, то есть heap[0]). Возвращаем undefined, если куча пустая.  

4. push(value):  

   • Добавляем элемент в конец массива.  

   • Затем вызваем _heapifyUp, чтобы «поднять» добавленный элемент на нужное место, сохраняя структуру кучи.  

5. pop():  

   • Забираем «верхний» (минимальный) элемент, переставляя при этом последний элемент массива наверх (с индексом 0), а потом опускаем его вниз, если нарушен порядок, вызывая _heapifyDown.  

6. _heapifyUp(index): служебный метод для «подъёма» элемента, если он меньше своего родителя, пока не будет восстановлен порядок кучи.  

7. _heapifyDown(index): служебный метод для «опускания» элемента, если он больше потомков, пока не будет восстановлен порядок кучи.  

8. _swap(i, j): служебный метод обмена местами элементов в массиве heap.  

-----

▎2. Определение структуры MaxHeap (максимальная куча)

▎Класс MaxHeap

class MaxHeap {
  constructor() {
    this.heap = [];
  }

  get size() {
    return this.heap.length;
  }

  peek() {
    return this.size === 0 ? undefined : this.heap[0];
  }

  push(value) {
    this.heap.push(value);
    this._heapifyUp(this.size - 1);
  }

  pop() {
    if (this.size === 0) return undefined;
    this._swap(0, this.size - 1);
    const maxValue = this.heap.pop();
    this._heapifyDown(0);
    return maxValue;
  }

  _heapifyUp(index) {
    // ...
  }

  _heapifyDown(index) {
    // ...
  }

  _swap(i, j) {
    // ...
  }
}


Что здесь происходит:  

• Логика очень похожа на MinHeap, только теперь мы хотим, чтобы в вершине всегда был максимальный элемент (а не минимальный).  

• При «поднятии» (_heapifyUp) и «опускании» (_heapifyDown) сравнения строятся так, чтобы самый большой элемент оказывался наверху.  

-----

▎3. Класс MedianFinder — хранение медианы с помощью двух куч

▎Общая схема

class MedianFinder {
  constructor() {
    this.maxHeap = new MaxHeap(); // нижняя половина
    this.minHeap = new MinHeap(); // верхняя половина
  }

  addNum(num) {
    // ...
  }

  findMedian() {
    // ...
  }
}


▎Подробности методов

▎Метод addNum(num)

addNum(num) {
  // 1. Определяем, куда кладём новое число
  if (
    this.maxHeap.size === 0 ||
    num <= this.maxHeap.peek()
  ) {
    // Если число меньше (или равно) верхушке maxHeap,
    // оно отправляется в "нижнюю половину"
    this.maxHeap.push(num);
  } else {
    // иначе — в "верхнюю половину"
    this.minHeap.push(num);
  }

  // 2. Балансируем кучи — разница в количестве элементов не должна быть больше 1
  if (this.maxHeap.size > this.minHeap.size + 1) {
    // если maxHeap слишком большая, перекладываем 1 элемент в minHeap
    const val = this.maxHeap.pop();
    this.minHeap.push(val);
  } else if (this.minHeap.size > this.maxHeap.size + 1) {
    // если minHeap слишком большая, перекладываем 1 элемент в maxHeap
    const val = this.minHeap.pop();
    this.maxHeap.push(val);
  }
}


Простыми словами:

ChatGPT 4.5 | DeepSeek | Midjourney, [31.03.2025 16:51]
1. Мы распределяем новые числа так, чтобы в maxHeap лежали «меньшие» числа (а сверху — самое большое из них). В minHeap — «большие» числа (а сверху — самое маленькое из них).  

2. Если новое число меньше или равно тому, что лежит сверху в maxHeap, оно идёт в «нижнюю» кучу (maxHeap). Иначе — в «верхнюю» (minHeap).  

3. После этого может нарушиться баланс (например, в одной куче стало на 2 элемента больше). Тогда мы «перекидываем» один элемент, чтобы обе кучи отличались не более чем на 1 элемент.  

▎Метод findMedian()

findMedian() {
  const totalSize = this.maxHeap.size + this.minHeap.size;
  if (totalSize === 0) {
    return null; // нет элементов
  }

  if (totalSize % 2 === 0) {
    // если общее кол-во элементов чётное
    return (this.maxHeap.peek() + this.minHeap.peek()) / 2;
  } else {
    // если нечётное
    if (this.maxHeap.size > this.minHeap.size) {
      return this.maxHeap.peek();
    } else {
      return this.minHeap.peek();
    }
  }
}


Простыми словами:  

1. Считаем общее число элементов. Если вообще нет чисел — возвращаем null.  

2. Если общее количество чётное (например, 2, 4, 6...), то медиана — это среднее между верхушкой maxHeap и верхушкой minHeap.  

3. Если общее количество нечётное (3, 5, 7...), тогда медианой будет вершина той кучи, в которой больше элементов.  

-----

▎4. Функция-пример: как искать медиану из массива

function findMedianUsingTwoHeaps(arr) {
  const medianFinder = new MedianFinder();

  // Добавляем по очереди все элементы массива
  for (const num of arr) {
    medianFinder.addNum(num);
  }

  // Получаем медиану
  return medianFinder.findMedian();
}


Что происходит:  

1. Создаём экземпляр MedianFinder, внутри которого есть наши две кучи.  

2. Идём по всем элементам массива arr, каждый элемент добавляем через addNum.  

3. По завершении возвращаем текущую медиану методом findMedian.  

-----

▎5. Пример использования

const arr1 = [5, 2, 8, 3, 1];
console.log(findMedianUsingTwoHeaps(arr1)); 
// Ожидаем 3 (средний элемент в [1, 2, 3, 5, 8])

const arr2 = [4, 1, 7, 10, 2, 6];
console.log(findMedianUsingTwoHeaps(arr2));
// Ожидаем 5 (среднее двух средних элементов в [1, 2, 4, 6, 7, 10])


-----

▎Краткий итог

• MinHeap — хранит «большую половину» чисел (самый маленький среди «больших» — наверху).  

• MaxHeap — хранит «меньшую половину» чисел (самый большой среди «маленьких» — наверху).  

• При добавлении числа решаем, в какую кучу оно пойдёт, а затем балансируем, чтобы размеры куч отличались не больше чем на 1 элемент.  

• Медиана берётся либо как среднее двух вершин (если общее количество чисел чётное), либо как вершина «большей» кучи (если нечётное).


ChatGPT 4.5 | DeepSeek | Midjourney, [31.03.2025 16:51]
Ниже мы возьмём код из предыдущего примера (две кучи, поиск медианы) и разберём его на более мелкие части, сопроводив пояснением «простыми словами».  

-----

▎1. Определение структуры MinHeap (минимальная куча)

▎Класс MinHeap

class MinHeap {
  constructor() {
    this.heap = [];
  }

  get size() {
    return this.heap.length;
  }

  peek() {
    return this.size === 0 ? undefined : this.heap[0];
  }

  push(value) {
    this.heap.push(value);
    this._heapifyUp(this.size - 1);
  }

  pop() {
    if (this.size === 0) return undefined;
    this._swap(0, this.size - 1);
    const minValue = this.heap.pop();
    this._heapifyDown(0);
    return minValue;
  }

  _heapifyUp(index) {
    // ...
  }

  _heapifyDown(index) {
    // ...
  }

  _swap(i, j) {
    // ...
  }
}


Что здесь происходит:  

1. Свойство heap: хранит все элементы кучи в виде массива.  

2. size: показывает, сколько сейчас элементов в куче.  

3. peek(): быстро получить «минимальный» элемент (для MinHeap это вершина, то есть heap[0]). Возвращаем undefined, если куча пустая.  

4. push(value):  

   • Добавляем элемент в конец массива.  

   • Затем вызваем _heapifyUp, чтобы «поднять» добавленный элемент на нужное место, сохраняя структуру кучи.  

5. pop():  

   • Забираем «верхний» (минимальный) элемент, переставляя при этом последний элемент массива наверх (с индексом 0), а потом опускаем его вниз, если нарушен порядок, вызывая _heapifyDown.  

6. _heapifyUp(index): служебный метод для «подъёма» элемента, если он меньше своего родителя, пока не будет восстановлен порядок кучи.  

7. _heapifyDown(index): служебный метод для «опускания» элемента, если он больше потомков, пока не будет восстановлен порядок кучи.  

8. _swap(i, j): служебный метод обмена местами элементов в массиве heap.  

-----

▎2. Определение структуры MaxHeap (максимальная куча)

▎Класс MaxHeap

class MaxHeap {
  constructor() {
    this.heap = [];
  }

  get size() {
    return this.heap.length;
  }

  peek() {
    return this.size === 0 ? undefined : this.heap[0];
  }

  push(value) {
    this.heap.push(value);
    this._heapifyUp(this.size - 1);
  }

  pop() {
    if (this.size === 0) return undefined;
    this._swap(0, this.size - 1);
    const maxValue = this.heap.pop();
    this._heapifyDown(0);
    return maxValue;
  }

  _heapifyUp(index) {
    // ...
  }

  _heapifyDown(index) {
    // ...
  }

  _swap(i, j) {
    // ...
  }
}


Что здесь происходит:  

• Логика очень похожа на MinHeap, только теперь мы хотим, чтобы в вершине всегда был максимальный элемент (а не минимальный).  

• При «поднятии» (_heapifyUp) и «опускании» (_heapifyDown) сравнения строятся так, чтобы самый большой элемент оказывался наверху.  

-----

▎3. Класс MedianFinder — хранение медианы с помощью двух куч

▎Общая схема

class MedianFinder {
  constructor() {
    this.maxHeap = new MaxHeap(); // нижняя половина
    this.minHeap = new MinHeap(); // верхняя половина
  }

  addNum(num) {
    // ...
  }

  findMedian() {
    // ...
  }
}


▎Подробности методов

▎Метод addNum(num)

addNum(num) {
  // 1. Определяем, куда кладём новое число
  if (
    this.maxHeap.size === 0 ||
    num <= this.maxHeap.peek()
  ) {
    // Если число меньше (или равно) верхушке maxHeap,
    // оно отправляется в "нижнюю половину"
    this.maxHeap.push(num);
  } else {
    // иначе — в "верхнюю половину"
    this.minHeap.push(num);
  }

  // 2. Балансируем кучи — разница в количестве элементов не должна быть больше 1
  if (this.maxHeap.size > this.minHeap.size + 1) {
    // если maxHeap слишком большая, перекладываем 1 элемент в minHeap
    const val = this.maxHeap.pop();
    this.minHeap.push(val);
  } else if (this.minHeap.size > this.maxHeap.size + 1) {
    // если minHeap слишком большая, перекладываем 1 элемент в maxHeap
    const val = this.minHeap.pop();
    this.maxHeap.push(val);
  }
}


Простыми словами:

ChatGPT 4.5 | DeepSeek | Midjourney, [31.03.2025 16:51]
1. Мы распределяем новые числа так, чтобы в maxHeap лежали «меньшие» числа (а сверху — самое большое из них). В minHeap — «большие» числа (а сверху — самое маленькое из них).  

2. Если новое число меньше или равно тому, что лежит сверху в maxHeap, оно идёт в «нижнюю» кучу (maxHeap). Иначе — в «верхнюю» (minHeap).  

3. После этого может нарушиться баланс (например, в одной куче стало на 2 элемента больше). Тогда мы «перекидываем» один элемент, чтобы обе кучи отличались не более чем на 1 элемент.  

▎Метод findMedian()

findMedian() {
  const totalSize = this.maxHeap.size + this.minHeap.size;
  if (totalSize === 0) {
    return null; // нет элементов
  }

  if (totalSize % 2 === 0) {
    // если общее кол-во элементов чётное
    return (this.maxHeap.peek() + this.minHeap.peek()) / 2;
  } else {
    // если нечётное
    if (this.maxHeap.size > this.minHeap.size) {
      return this.maxHeap.peek();
    } else {
      return this.minHeap.peek();
    }
  }
}


Простыми словами:  

1. Считаем общее число элементов. Если вообще нет чисел — возвращаем null.  

2. Если общее количество чётное (например, 2, 4, 6...), то медиана — это среднее между верхушкой maxHeap и верхушкой minHeap.  

3. Если общее количество нечётное (3, 5, 7...), тогда медианой будет вершина той кучи, в которой больше элементов.  

-----

▎4. Функция-пример: как искать медиану из массива

function findMedianUsingTwoHeaps(arr) {
  const medianFinder = new MedianFinder();

  // Добавляем по очереди все элементы массива
  for (const num of arr) {
    medianFinder.addNum(num);
  }

  // Получаем медиану
  return medianFinder.findMedian();
}


Что происходит:  

1. Создаём экземпляр MedianFinder, внутри которого есть наши две кучи.  

2. Идём по всем элементам массива arr, каждый элемент добавляем через addNum.  

3. По завершении возвращаем текущую медиану методом findMedian.  

-----

▎5. Пример использования

const arr1 = [5, 2, 8, 3, 1];
console.log(findMedianUsingTwoHeaps(arr1)); 
// Ожидаем 3 (средний элемент в [1, 2, 3, 5, 8])

const arr2 = [4, 1, 7, 10, 2, 6];
console.log(findMedianUsingTwoHeaps(arr2));
// Ожидаем 5 (среднее двух средних элементов в [1, 2, 4, 6, 7, 10])


-----

▎Краткий итог

• MinHeap — хранит «большую половину» чисел (самый маленький среди «больших» — наверху).  

• MaxHeap — хранит «меньшую половину» чисел (самый большой среди «маленьких» — наверху).  

• При добавлении числа решаем, в какую кучу оно пойдёт, а затем балансируем, чтобы размеры куч отличались не больше чем на 1 элемент.  

• Медиана берётся либо как среднее двух вершин (если общее количество чисел чётное), либо как вершина «большей» кучи (если нечётное).

ChatGPT 4.5 | DeepSeek | Midjourney, [31.03.2025 17:57]
Quickselect простыми словами — это метод, чтобы быстро найти k-й по величине элемент (например, 5-й наименьший) в неотсортированном массиве, не тратя время на полную сортировку всего массива.

1. Выбираем опорный элемент (pivot). Обычно это делают случайным образом или берут середину.

2. Разделяем массив на две части:  

   • Элементы, которые меньше опорного, идут налево.  

   • Элементы, которые больше или равны опорному, идут направо.  

3. Смотрим, где оказался опорный элемент относительно позиции k:  

   • Если опорный элемент встал точно на k-ю позицию (для удобства счёта с нуля — на индекс k-1), то мы закончили: это и есть нужный элемент.  

   • Если опорный элемент «оказался левее» (его индекс меньше, чем k), значит k-й элемент лежит правее. Запускаем алгоритм для правой части.  

   • Если опорный элемент «оказался правее» (его индекс больше, чем k), значит k-й элемент лежит левее. Запускаем алгоритм для левой части.  

Почему это быстрее, чем сортировка?  

• Quickselect «не докручивает» полный QuickSort: мы не сортируем обе стороны массива до конца, а только ту часть, где точно лежит нужный элемент. За счёт этого не тратится время на упорядочивание лишних элементов.  

Время работы: в среднем алгоритм работает за O(n), но в худшем случае может быть O(n^2), если опорные элементы выбираются совсем неудачно. 
