The median is the middle value in an ordered integer list. If the size of the list is even, there is no middle value. So the median is the mean of the two middle values.

For examples, if arr = [2,3,4], the median is 3.
For examples, if arr = [1,2,3,4], the median is (2 + 3) / 2 = 2.5.
You are given an integer array nums and an integer k. There is a sliding window of size k which is moving from the very left of the array to the very right. You can only see the k numbers in the window. Each time the sliding window moves right by one position.

Return the median array for each window in the original array. Answers within 10-5 of the actual value will be accepted.

 

Example 1:

Input: nums = [1,3,-1,-3,5,3,6,7], k = 3
Output: [1.00000,-1.00000,-1.00000,3.00000,5.00000,6.00000]
Explanation: 
Window position                Median
---------------                -----
[1  3  -1] -3  5  3  6  7        1
 1 [3  -1  -3] 5  3  6  7       -1
 1  3 [-1  -3  5] 3  6  7       -1
 1  3  -1 [-3  5  3] 6  7        3
 1  3  -1  -3 [5  3  6] 7        5
 1  3  -1  -3  5 [3  6  7]       6
Example 2:

Input: nums = [1,2,3,4,2,3,1,4,2], k = 3
Output: [2.00000,3.00000,3.00000,3.00000,2.00000,3.00000,2.00000]
 

Constraints:

1 <= k <= nums.length <= 105
-231 <= nums[i] <= 231 - 1
Задача "Скользящая медиана"  
Нужно найти медиану для каждого положения окна фиксированного размера k, которое двигается по массиву. Медиана — это средний элемент в отсортированном списке. Если элементов чётное количество, медиана — среднее двух центральных.

Алгоритм решения:

1. Две кучи для балансировки элементов:
   - max_heap хранит меньшую половину элементов (максимальный элемент на вершине).
   - min_heap хранит большую половину (минимальный элемент на вершине).
   - В max_heap может быть на 1 элемент больше, чем в min_heap, если k нечётное.

2. Добавление элемента:
   - Новый элемент добавляется в max_heap, если он меньше или равен её вершине, иначе — в min_heap.
   - После добавления проверяется баланс между кучами:
     - Если max_heap больше min_heap более чем на 1, верхний элемент max_heap переносится в min_heap.
     - Если min_heap больше max_heap, верхний элемент min_heap переносится в max_heap.

3. Удаление устаревшего элемента:
   - При сдвиге окна удаляется элемент, выходящий за его границы.
   - Определяется, в какой куче находится элемент:
     - Если элемент ≤ вершины max_heap (после очистки удалённых), он удаляется из max_heap.
     - Иначе — из min_heap.
   - Удаление "ленивое" — элемент помечается как удалённый в хэш-таблице, чтобы физически убрать его позже.

4. Ленивое удаление и очистка куч:
   - Перед любыми операциями с вершинами куч удаляются все помеченные элементы с вершины.
   - Хэш-таблицы (`hash_map_max`, `hash_map_min`) отслеживают количество "удалённых" элементов в каждой куче.

5. Вычисление медианы:
   - После очистки куч:
     - Если k нечётное: медиана — вершина max_heap.
     - Если чётное: среднее между вершинами max_heap и min_heap.

Сложность:  
- Вставка и удаление элементов: O(log k).
- Балансировка куч: O(1).
- Общая сложность: O(n log k), где n — длина массива.

Ключевые моменты:
- Использование двух куч для разделения элементов на две половины.
- Ленивое удаление для эффективного управления элементами.
- Балансировка куч для поддержания корректного размера.
- Очистка вершин куч перед критическими операциями.
Задача (просто о сложном)  
Дан массив чисел и целое число *k*. Нужно последовательно «скользить» по этому массиву «окном» размера *k*:  

• На первом шаге окно включает первые *k* чисел массива.  

• На втором шаге — элементы со 2-го по (k+1)-й,  

• и так далее, пока окно не дойдет до конца массива.  

На каждом шаге нужно найти медиану чисел, попавших в текущее окно, и сохранить ее в ответ.

Что такое медиана?  

• Если в окне нечётное количество чисел *(k нечетное)*, медиана — это просто средний элемент, когда все числа окна отсортированы.  

• Если в окне чётное количество чисел *(k четное)*, медиана — это среднее арифметическое двух серединных элементов в отсортированном виде.

---

▎Подход к решению без кода

▎1. Наивный метод

1. Для каждого положения окна берем его элементы.

2. Сортируем элементы окна.

3. Находим медиану по определению (один элемент в случае нечетного *k*, или среднее арифметическое двух элементов в случае четного *k*).

4. Сдвигаем окно на 1 позицию вправо и повторяем всё заново.  

Сложность:  

• Сортировка окна из *k* элементов занимает O(k log k).  

• Из-за того, что мы двигаемся по окну (n - k + 1) раз, общая сложность будет O((n - k + 1) × k log k).  

• Это может быть достаточно медленно, если *n* и *k* очень большие.

▎2. Эффективный метод (две кучи или сбалансированное дерево)

Чтобы находить медиану более эффективно, часто используют структуру данных из двух куч (или сбалансированного дерева):

1. Max-куча (приоритетная очередь) — хранит меньшую половину чисел.

2. Min-куча — хранит большую половину чисел.

При этом заботимся о том, чтобы:  

• Все элементы *max*-кучи были меньше или равны всем элементам *min*-кучи.  

• Количество элементов в кучах различалось не более чем на 1. Благодаря этому медиана быстро определяется:  

  • Если суммарное количество элементов нечётно, медиана находится на вершине той кучи, где больше элементов.  

  • Если чётно, медиана — это среднее значений, лежащих на вершинах обеих куч.

Как адаптировать к «скользящему окну»:  

1. Сначала заполняем две кучи элементами первого окна. Балансируем (число элементов в кучах не должно отличаться больше чем на 1).  

2. Когда окно сдвигается на 1:

   • Удаляем выпадающий элемент (тот, что уходит из окна) из соответствующей кучи. Чтобы найти его эффективно, можно хранить «вспомогательную структуру» (к примеру, дерево поиска или индекс в куче), но в общем случае — это занимает O(log k) при наличии хорошей структуры данных.  

   • Добавляем новый элемент, который приходит в окно, в одну из куч так, чтобы сохранялся баланс. Тоже за O(log k).  

   • Смотрим на вершины куч и находим медиану.  

Сложность:  

• Каждый сдвиг окна (таких сдвигов (n - k + 1)) требует двух логарифмических операций (добавление и удаление с последующей балансировкой), то есть примерно O(log k) на один сдвиг.  

• Итоговая асимптотика: O(n log k).

---

▎Итоговая идея

• Если *n* небольшое или *k* велико, можно просто брать с каждого окна элементы, сортировать и находить медиану.  

• Если нужны лучшие результаты по времени на больших данных, используют сложные структуры (две кучи или дерево), чтобы добавлять и удалять элементы из окна за O(log k).  

• В результате медиа́ны собираются в итоговый массив, размер которого будет (n - k + 1).
Для эффективного нахождения медианы из массива в JavaScript можно использовать два подхода. Вот реализация базового метода с сортировкой (простой и понятный) и оптимизированного с использованием Quickselect (быстрее для больших данных).

---

### 1. Базовый метод (с сортировкой)
function findMedianBasic(arr) {
    if (arr.length === 0) return null;
    
    // Создаем копию и сортируем
    const sorted = [...arr].sort((a, b) => a - b);
    const mid = Math.floor(sorted.length / 2);
    
    // Для четного и нечетного количества элементов
    return sorted.length % 2 === 0 
        ? (sorted[mid - 1] + sorted[mid]) / 2 
        : sorted[mid];
}

Особенности:
- Простота реализации.
- Сложность: O(n log n) из-за сортировки.
- Подходит для небольших массивов.

---

### 2. Оптимизированный метод (Quickselect)
function findMedianOptimized(arr) {
    if (arr.length === 0) return null;

    const findKth = (k, left, right) => {
        while (true) {
            if (left === right) return arr[left];
            
            // Выбор опорного элемента и разделение массива
            let pivotIdx = partition(left, right);
            
            if (k === pivotIdx) return arr[k];
            else if (k < pivotIdx) right = pivotIdx - 1;
            else left = pivotIdx + 1;
        }
    };

    const partition = (left, right) => {
        const pivot = arr[right];
        let i = left;
        for (let j = left; j < right; j++) {
            if (arr[j] < pivot) {
                [arr[i], arr[j]] = [arr[j], arr[i]];
                i++;
            }
        }
        [arr[i], arr[right]] = [arr[right], arr[i]];
        return i;
    };

    const n = arr.length;
    const mid = Math.floor(n / 2);
    
    // Для нечетного и четного количества элементов
    if (n % 2 === 1) {
        return findKth(mid, 0, n - 1);
    } else {
        const a = findKth(mid - 1, 0, n - 1);
        const b = findKth(mid, 0, n - 1);
        return (a + b) / 2;
    }
}

Особенности:
- Использует алгоритм Quickselect для поиска k-го элемента без полной сортировки.
- Средняя сложность: O(n), но в худшем случае O(n^2).
- Подходит для больших массивов.

---

### Пример использования:
const data = [5, 2, 9, 1, 5, 6];
console.log(findMedianBasic(data)); // 5
console.log(findMedianOptimized(data)); // 5

### Как выбрать метод?
- Используйте `findMedianBasic`, если нужна простота и массив небольшой.
- Используйте `findMedianOptimized`, если данные очень большие и требуется оптимизация скорости (но учитывайте риск худшего случая).
