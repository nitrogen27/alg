Ниже описаны основные идеи и приёмы, связанные с алгоритмами обхода в глубину (DFS) и обхода в ширину (BFS), а также приведены упрощённые примеры реализации на JavaScript. Материал пригодится для решения широкого круга задач: от поиска путей в графе до работы с двумерными матрицами (например, «карты островов» и т.д.).

---

▎1. Общая теория и различия между DFS и BFS

▎Обход в глубину (DFS — Depth-First Search)

1. Идея:  

   • Углубляемся в граф (или структуру данных) как можно дальше по одному из направлений (пути), пока не упрёмся в «конец».  

   • Затем «поднимаемся» (возвращаемся назад) и идём в следующий непосещённый путь.

2. Реализация:

   • Рекурсивно (используя стек вызовов) либо итеративно (явно создавая стек).

3. Применение:  

   • Поиск пути (не обязательно кратчайшего) в связном графе.  

   • Поиск связных компонент в неориентированном графе (или подсчёт «островов» на матрице).  

   • Алгоритмы топологической сортировки (в ориентированных ациклических графах).  

   • Проверка на наличие цикла в графе.  

4. Особенность:  

   • Проходит «вглубь» от стартовой вершины, поэтому первым делом «посещает» конечные точки ветви.

▎Обход в ширину (BFS — Breadth-First Search)

1. Идея:  

   • Начинаем с начальной вершины и сначала «раскрываем» все вершины на расстоянии 1, потом все вершины на расстоянии 2 и т.д.

2. Реализация:  

   • Используем очередь (FIFO). Сначала в очередь кладём стартовую вершину. После извлечения из очереди вершины, все её непосещённые соседи добавляются в очередь.

3. Применение:  

   • Нахождение кратчайшего пути в невзвешенном графе (или сетке).  

   • Уровневый обход в деревьях (например, обход по слоям).  

   • Проверка, является ли граф двудольным (bipartite).  

4. Особенность:  

   • Обходит вершины слоями (уровнями): сначала все соседи стартовой точки, затем соседи соседей и т.д.

---

▎2. Устройство графа для обхода

Обычно граф представляют в виде:

• Списка смежности (adjacency list), где для каждой вершины хранится массив/список соседей. В JavaScript это может быть объект вида:
  
  const graph = {
    A: ["B", "C"],
    B: ["A", "D"],
    C: ["A", "E"],
    D: ["B"],
    E: ["C"]
    // ...
  };
  

• Матрицы смежности (adjacency matrix), двумерный массив, где matrix[i][j] = 1, если есть связь между i и j, и 0, если нет.

• Двумерной сетки (матрицы), когда решаем задачи вида «поиск пути в лабиринте» или «поиск числа островов». Там вершинами считаются все ячейки, а ребрами — соседства сверху/снизу/слева/справа.

---

▎3. DFS (Обход в глубину) на JavaScript

▎Рекурсивный вариант

/**
 * graph: объект вида { A: ["B","C"], B: ["A","D"], ... }
 * start: начальная вершина (например, "A")
 * visited: множество (Set) для хранения уже посещённых вершин
 */
function dfs(graph, start, visited = new Set()) {
  // 1. Посетить текущую вершину
  visited.add(start);
  console.log("Посетили:", start);

  // 2. Обойти всех соседей, если они не посещены
  for (let neighbor of graph[start]) {
    if (!visited.has(neighbor)) {
      dfs(graph, neighbor, visited);
    }
  }
}


Ключевые моменты:

1. Не забывать помечать вершину как посещённую до рекурсивного вызова для её соседей, чтобы избежать зацикливания.  

2. Рекурсия может быть опасна в очень больших графах (риск переполнения стека). Тогда применяют итеративный подход со стеком.

▎Итеративный вариант (со стеком)

function dfsIterative(graph, start) {
  const stack = [start];
  const visited = new Set();

  while (stack.length > 0) {
    const vertex = stack.pop(); // забираем верхнюю вершину из стека

    if (!visited.has(vertex)) {
      visited.add(vertex);
      console.log("Посетили:", vertex);

      // Добавляем всех соседей в стек
      for (let neighbor of graph[vertex]) {
        if (!visited.has(neighbor)) {
          stack.push(neighbor);
        }
      }
    }
  }
}


---

▎4. BFS (Обход в ширину) на JavaScript

▎Итеративный вариант (с очередью)

function bfs(graph, start) {
  const queue = [start];
  const visited = new Set([start]);

  while (queue.length > 0) {
    const vertex = queue.shift(); // извлекаем элемент из начала очереди
    console.log("Посетили:", vertex);

    // Перебираем всех соседей
    for (let neighbor of graph[vertex]) {
      if (!visited.has(neighbor)) {
        visited.add(neighbor);
        queue.push(neighbor);
      }
    }
  }
}


Ключевые моменты:

1. В отличие от DFS, здесь мы используем очередь (FIFO): первым вошёл — первым вышел (shift).  

2. Маркируем вершину как посещённую сразу, когда кладём её в очередь (или когда извлекаем — детали зависят от реализации, важно лишь избежать повторов).

---

▎5. Примеры приёмов и распространённые задачи

1. Поиск кратчайшего пути (BFS):

   • В невзвешенном графе/лабиринте именно BFS даст нам кратчайший путь по числу рёбер (или «шагов»). В процессе обхода можно сохранять «предка» каждой вершины, чтобы восстановить найденный путь.

2. Подсчёт связных компонент (DFS или BFS):

   • Если у нас имеется граф, который может быть несвязным, мы можем «запустить» DFS/BFS из каждой непосещённой вершины. Каждый запуск найдёт одну связную компоненту.

   • Количество запусков (или количество раз, когда обнаруживаем новую непосещённую вершину) и будет количеством связных компонент.

3. «Острова» в матрице (DFS или BFS):

   • Если граф задан в виде двумерного массива (например, задачи типа «Number of Islands»), то мы представляем каждую ячейку как вершину, а рёбра — это переходы между соседними клетками (сверху, снизу, слева, справа).

   • Запускаем DFS/BFS из клетки с землёй (1), помечаем все смежные клетки (1) как посещённые, и считаем это одним островом. Затем продолжаем обходить всю матрицу.

   
4. Проверка двудольности (BFS + раскраска)

   • При обходе BFS можно «раскрашивать» вершины в два цвета попеременно. Если обнаружили конфликт (соседи оказываются в одном цвете), то граф не двудольный.

5. Поиск цикла (DFS)

   • Во время DFS можно «следить» за вершинами, которые в данный момент находятся в стеке рекурсии. Если мы натыкаемся на вершину, которую ещё не завершили обрабатывать, то есть «обратное ребро», следовательно, есть цикл.

---

▎6. Практические советы

1. Используйте структуру данных Set или «маску посещений» (массив булевых флагов) для отслеживания посещённых элементов.

2. Будьте аккуратны с границами (особенно в двумерных массивах), чтобы не выйти за пределы.

3. Выбирайте рекурсивный DFS осторожно, если глубина рекурсии может быть очень велика (лучше использовать стек).

4. В BFS можно использовать очередь как из библиотеки (например, массив в JS, но имейте в виду, что shift() — операция O(n)). Если нужен более быстрый метод, можно реализовать очередь на двусторонней структуре (например, используя push и pop с двух сторон, держась подальше от «середины» массива).

---

▎7. Заключение

• DFS и BFS — фундаментальные алгоритмы для работы с графами.  

• DFS: «Глубокий» подход, ориентированный на полное исследование одного пути, прежде чем двигаться к следующему.  

• BFS: «Широкий» (пошаговый, послойный) обход, часто применяемый, когда нужно найти кратчайший путь или обойти граф в порядке «слоёв».

Умея применять эти два подхода, вы сможете решать множество типовых задач (поиск путей, подсчёт компонентов, проверка свойств графа и многое другое). А написав универсальные функции dfs и bfs, вы легко адаптируете их под специфику любой конкретной задачи в JavaScript.
