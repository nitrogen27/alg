### Подробное решение задачи "Find Duplicate Subtrees"Add commentMore actions

#### **Основная идея**
Для обнаружения дублирующихся поддеревьев необходимо уникально идентифицировать структуру и значения каждого поддерева. Эффективный подход — преобразовать каждое поддерево в строковое представление (сериализация), которое однозначно описывает его структуру. Затем, используя хеш-таблицу, отслеживаем частоту встречаемости каждой сериализации. Если сериализация встречается ровно два раза, соответствующий корень поддерева добавляется в результат.

#### **Шаги решения**
1. **Сериализация поддеревьев**:
   - Каждое поддерево рекурсивно преобразуется в строку формата: `корень(левое_поддерево)(правое_поддерево)`.
   - Пустые узлы обозначаются символом (например, `"#"`), чтобы сохранить структуру дерева.
   - Пример:
     - Лист `4` → `"4(#)(#)"`.
     - Поддерево с корнем `2` и левым листом `4` → `"2(4(#)(#))(#)"`.

2. **Отслеживание дубликатов**:
   - Используется словарь (`serialization_count`), где ключ — сериализация поддерева, значение — количество её вхождений.
   - При обходе дерева для каждой сериализации:
     - Увеличиваем счётчик в словаре.
     - Если счётчик становится равным 2, корень текущего поддерева добавляется в результат.

3. **Рекурсивный обход дерева**:
   - Начинаем с корня дерева.
   - Для каждого узла:
     - Рекурсивно сериализуем левое и правое поддеревья.
     - Формируем строку для текущего поддерева.
     - Обновляем счётчик в словаре и проверяем условие добавления в результат.

4. **Возврат результата**:
   - Результатом является список корней дублирующихся поддеревьев (по одному на каждый тип).

#### **Пример работы**
Рассмотрим дерево:
```
     1
    / \
   2   3
  /   / \
 4   2   4
    /
   4
```

**Сериализация поддеревьев**:
1. Листья `4` → `"4(#)(#)"` (встречается 3 раза).
2. Поддерево с корнем `2` (левое от корня) → `"2(4(#)(#))(#)"`.
3. Поддерево с корнем `2` (в правом поддереве) → `"2(4(#)(#))(#)"` (дубликат).
4. Поддерево с корнем `3` → `"3(2(4(#)(#))(#))(4(#)(#))"`.

**Обнаружение дубликатов**:
- Сериализация `"4(#)(#)"`:
  - Первое вхождение: счётчик = 1 (не добавляем).
  - Второе вхождение: счётчик = 2 (добавляем корень второго листа `4` в результат).
  - Третье вхождение: счётчик = 3 (пропускаем).
- Сериализация `"2(4(#)(#))(#)"`:
  - Первое вхождение: счётчик = 1 (не добавляем).
  - Второе вхождение: счётчик = 2 (добавляем корень второго поддерева `2` в результат).

**Результат**: `[узел_4, узел_2]` (порядок произвольный).

#### **Ключевые особенности**
- **Уникальность сериализации**: Строка однозначно определяет форму и значения поддерева. Например, поддеревья `A` и `B` идентичны, если их сериализации совпадают.
- **Эффективность добавления в результат**: Узел добавляется при **втором** вхождении сериализации, что гарантирует единственность представителя для каждого типа дубликата.
- **Обработка пустых узлов**: Символ `"#"` обеспечивает корректное сравнение структур (например, отличает `2(4)` от `2`).

#### **Сложность решения**
- **Временная сложность**: O(N²), где N — количество узлов. Каждая сериализация может занимать O(N) времени, и всего сериализаций N.
- **Пространственная сложность**: O(N²) для хранения всех сериализаций.

#### **Оптимизация**
Для больших деревьев можно заменить строки на числовые идентификаторы:
- Использовать словарь `serialization_to_id`, сопоставляющий сериализацию с уникальным ID.
- Вместо строк возвращать ID, что сокращает время сравнения и память.
- Пример: 
  - `"4(#)(#)"` → ID = 1.
  - `"2(4(#)(#))(#)"` = `"2(1)(0)"` → ID = 2 (где `0` — ID для `"#"`).

#### **Заключение**
Решение эффективно обнаруживает дубликаты за счёт:
1. Рекурсивной сериализации поддеревьев.
2. Отслеживания частоты сериализаций через хеш-таблицу.Add commentMore actions
3. Добавления корней при втором вхождении дубликата.
Результат содержит по одному представителю для каждого типа дублирующихся поддеревьев.
### Подробное решение задачи "Find Duplicate Subtrees"

#### **Основная идея**
Для обнаружения дублирующихся поддеревьев необходимо уникально идентифицировать структуру и значения каждого поддерева. Эффективный подход — преобразовать каждое поддерево в строковое представление (сериализация), которое однозначно описывает его структуру. Затем, используя хеш-таблицу, отслеживаем частоту встречаемости каждой сериализации. Если сериализация встречается ровно два раза, соответствующий корень поддерева добавляется в результат.

#### **Шаги решения**
1. **Сериализация поддеревьев**:
   - Каждое поддерево рекурсивно преобразуется в строку формата: `корень(левое_поддерево)(правое_поддерево)`.
   - Пустые узлы обозначаются символом (например, `"#"`), чтобы сохранить структуру дерева.
   - Пример:
     - Лист `4` → `"4(#)(#)"`.
     - Поддерево с корнем `2` и левым листом `4` → `"2(4(#)(#))(#)"`.

2. **Отслеживание дубликатов**:
   - Используется словарь (`serialization_count`), где ключ — сериализация поддерева, значение — количество её вхождений.
   - При обходе дерева для каждой сериализации:
     - Увеличиваем счётчик в словаре.
     - Если счётчик становится равным 2, корень текущего поддерева добавляется в результат.

3. **Рекурсивный обход дерева**:
   - Начинаем с корня дерева.
   - Для каждого узла:
     - Рекурсивно сериализуем левое и правое поддеревья.
     - Формируем строку для текущего поддерева.
     - Обновляем счётчик в словаре и проверяем условие добавления в результат.

4. **Возврат результата**:
   - Результатом является список корней дублирующихся поддеревьев (по одному на каждый тип).

#### **Пример работы**
Рассмотрим дерево:
```
     1
    / \
   2   3
  /   / \
 4   2   4
    /
   4
```

**Сериализация поддеревьев**:
1. Листья `4` → `"4(#)(#)"` (встречается 3 раза).
2. Поддерево с корнем `2` (левое от корня) → `"2(4(#)(#))(#)"`.
3. Поддерево с корнем `2` (в правом поддереве) → `"2(4(#)(#))(#)"` (дубликат).
4. Поддерево с корнем `3` → `"3(2(4(#)(#))(#))(4(#)(#))"`.

**Обнаружение дубликатов**:
- Сериализация `"4(#)(#)"`:
  - Первое вхождение: счётчик = 1 (не добавляем).
  - Второе вхождение: счётчик = 2 (добавляем корень второго листа `4` в результат).
  - Третье вхождение: счётчик = 3 (пропускаем).
- Сериализация `"2(4(#)(#))(#)"`:
  - Первое вхождение: счётчик = 1 (не добавляем).
  - Второе вхождение: счётчик = 2 (добавляем корень второго поддерева `2` в результат).

**Результат**: `[узел_4, узел_2]` (порядок произвольный).

#### **Ключевые особенности**
- **Уникальность сериализации**: Строка однозначно определяет форму и значения поддерева. Например, поддеревья `A` и `B` идентичны, если их сериализации совпадают.
- **Эффективность добавления в результат**: Узел добавляется при **втором** вхождении сериализации, что гарантирует единственность представителя для каждого типа дубликата.
- **Обработка пустых узлов**: Символ `"#"` обеспечивает корректное сравнение структур (например, отличает `2(4)` от `2`).

#### **Сложность решения**
- **Временная сложность**: O(N²), где N — количество узлов. Каждая сериализация может занимать O(N) времени, и всего сериализаций N.
- **Пространственная сложность**: O(N²) для хранения всех сериализаций.

#### **Оптимизация**
Для больших деревьев можно заменить строки на числовые идентификаторы:
- Использовать словарь `serialization_to_id`, сопоставляющий сериализацию с уникальным ID.
- Вместо строк возвращать ID, что сокращает время сравнения и память.
- Пример: 
  - `"4(#)(#)"` → ID = 1.
  - `"2(4(#)(#))(#)"` = `"2(1)(0)"` → ID = 2 (где `0` — ID для `"#"`).

#### **Заключение**
Решение эффективно обнаруживает дубликаты за счёт:
1. Рекурсивной сериализации поддеревьев.
2. Отслеживания частоты сериализаций через хеш-таблицу.
3. Добавления корней при втором вхождении дубликата.
Результат содержит по одному представителю для каждого типа дублирующихся поддеревьев.
Для решения задачи поиска дублирующихся поддеревьев в бинарном дереве за линейное время используется обход дерева в глубину (DFS) с пост-порядком. Каждому уникальному поддереву присваивается уникальный идентификатор (UID) на основе значения корня, UID левого и правого поддеревьев. Это позволяет эффективно сравнивать поддеревья, используя словарь для отслеживания уже встреченных поддеревьев и их частот.

### Алгоритм:
1. **Инициализация**:
   - `uidCounter` - счетчик для генерации уникальных идентификаторов.
   - `tripletToUid` - словарь для отображения триплетов (значение корня, UID левого поддерева, UID правого поддерева) в UID.
   - `countMap` - словарь для подсчета количества вхождений каждого UID.
   - `result` - список корней дублирующихся поддеревьев.

2. **Рекурсивный обход дерева (DFS)**:
   - Для узла `null` возвращается UID `0`.
   - Рекурсивно обрабатываются левое и правое поддеревья.
   - Формируется триплет: `(значение_узла, UID_левого_поддерева, UID_правого_поддерева)`.
   - Если триплет уже существует в `tripletToUid`, увеличивается счетчик в `countMap`. Если счетчик становится равным 2, узел добавляется в `result`.
   - Если триплет новый, ему присваивается новый UID, который сохраняется в `tripletToUid`, а в `countMap` записывается 1.

3. **Возврат результата**:
   - После обхода всего дерева возвращается список `result`.

### Решение:
```javascript
function findDuplicateSubtrees(root) {
    let uidCounter = 1;
    const tripletToUid = new Map();
    const countMap = new Map();
    const result = [];
    
    function dfs(node) {
        if (!node) return 0;
        
        const leftUid = dfs(node.left);
        const rightUid = dfs(node.right);
        
        const triplet = `${node.val},${leftUid},${rightUid}`;
        
        if (tripletToUid.has(triplet)) {
            const existingUid = tripletToUid.get(triplet);
            const currentCount = countMap.get(existingUid) || 0;
            const newCount = currentCount + 1;
            countMap.set(existingUid, newCount);
            if (newCount === 2) {
                result.push(node);
            }
            return existingUid;
        } else {
            tripletToUid.set(triplet, uidCounter);
            countMap.set(uidCounter, 1);
            uidCounter++;
            return uidCounter - 1;
        }
    }
    
    dfs(root);
    return result;
}
```

### Объяснение:
- **UID присваивается каждому уникальному поддереву** на основе триплета `(значение_узла, UID_левого_поддерева, UID_правого_поддерева)`, что позволяет однозначно идентифицировать структуру поддерева.
- **Словари `tripletToUid` и `countMap`** обеспечивают эффективную проверку дубликатов за O(1) в среднем.
- **Добавление в результат** происходит при втором вхождении поддерева, что гарантирует включение каждого дубликата только один раз.
- **Сложность алгоритма** O(n), где n — количество узлов, так как каждый узел обрабатывается ровно один раз, а операции со словарями выполняются за O(1).

Это решение эффективно обрабатывает деревья, обеспечивая линейную временную сложность и оптимальное использование памяти.
