
### Подробное решение задачи "Find Duplicate Subtrees"

#### **Основная идея**
Для обнаружения дублирующихся поддеревьев необходимо уникально идентифицировать структуру и значения каждого поддерева. Эффективный подход — преобразовать каждое поддерево в строковое представление (сериализация), которое однозначно описывает его структуру. Затем, используя хеш-таблицу, отслеживаем частоту встречаемости каждой сериализации. Если сериализация встречается ровно два раза, соответствующий корень поддерева добавляется в результат.

#### **Шаги решения**
1. **Сериализация поддеревьев**:
   - Каждое поддерево рекурсивно преобразуется в строку формата: `корень(левое_поддерево)(правое_поддерево)`.
   - Пустые узлы обозначаются символом (например, `"#"`), чтобы сохранить структуру дерева.
   - Пример:
     - Лист `4` → `"4(#)(#)"`.
     - Поддерево с корнем `2` и левым листом `4` → `"2(4(#)(#))(#)"`.

2. **Отслеживание дубликатов**:
   - Используется словарь (`serialization_count`), где ключ — сериализация поддерева, значение — количество её вхождений.
   - При обходе дерева для каждой сериализации:
     - Увеличиваем счётчик в словаре.
     - Если счётчик становится равным 2, корень текущего поддерева добавляется в результат.

3. **Рекурсивный обход дерева**:
   - Начинаем с корня дерева.
   - Для каждого узла:
     - Рекурсивно сериализуем левое и правое поддеревья.
     - Формируем строку для текущего поддерева.
     - Обновляем счётчик в словаре и проверяем условие добавления в результат.

4. **Возврат результата**:
   - Результатом является список корней дублирующихся поддеревьев (по одному на каждый тип).

#### **Пример работы**
Рассмотрим дерево:
```
     1
    / \
   2   3
  /   / \
 4   2   4
    /
   4
```

**Сериализация поддеревьев**:
1. Листья `4` → `"4(#)(#)"` (встречается 3 раза).
2. Поддерево с корнем `2` (левое от корня) → `"2(4(#)(#))(#)"`.
3. Поддерево с корнем `2` (в правом поддереве) → `"2(4(#)(#))(#)"` (дубликат).
4. Поддерево с корнем `3` → `"3(2(4(#)(#))(#))(4(#)(#))"`.

**Обнаружение дубликатов**:
- Сериализация `"4(#)(#)"`:
  - Первое вхождение: счётчик = 1 (не добавляем).
  - Второе вхождение: счётчик = 2 (добавляем корень второго листа `4` в результат).
  - Третье вхождение: счётчик = 3 (пропускаем).
- Сериализация `"2(4(#)(#))(#)"`:
  - Первое вхождение: счётчик = 1 (не добавляем).
  - Второе вхождение: счётчик = 2 (добавляем корень второго поддерева `2` в результат).

**Результат**: `[узел_4, узел_2]` (порядок произвольный).

#### **Ключевые особенности**
- **Уникальность сериализации**: Строка однозначно определяет форму и значения поддерева. Например, поддеревья `A` и `B` идентичны, если их сериализации совпадают.
- **Эффективность добавления в результат**: Узел добавляется при **втором** вхождении сериализации, что гарантирует единственность представителя для каждого типа дубликата.
- **Обработка пустых узлов**: Символ `"#"` обеспечивает корректное сравнение структур (например, отличает `2(4)` от `2`).

#### **Сложность решения**
- **Временная сложность**: O(N²), где N — количество узлов. Каждая сериализация может занимать O(N) времени, и всего сериализаций N.
- **Пространственная сложность**: O(N²) для хранения всех сериализаций.

#### **Оптимизация**
Для больших деревьев можно заменить строки на числовые идентификаторы:
- Использовать словарь `serialization_to_id`, сопоставляющий сериализацию с уникальным ID.
- Вместо строк возвращать ID, что сокращает время сравнения и память.
- Пример: 
  - `"4(#)(#)"` → ID = 1.
  - `"2(4(#)(#))(#)"` = `"2(1)(0)"` → ID = 2 (где `0` — ID для `"#"`).

#### **Заключение**
Решение эффективно обнаруживает дубликаты за счёт:
1. Рекурсивной сериализации поддеревьев.
2. Отслеживания частоты сериализаций через хеш-таблицу.
3. Добавления корней при втором вхождении дубликата.
Результат содержит по одному представителю для каждого типа дублирующихся поддеревьев.
